<html>
<!--
 # SPDX-FileCopyrightText: Copyright (c) 2023-2025 Objectionary.com
 # SPDX-License-Identifier: MIT
-->
<head>
  <title>after-jd</title>
  <link href="https://cdn.jsdelivr.net/gh/yegor256/tacit@gh-pages/tacit-css.min.css", rel="stylesheet"/>
  <link href="https://cdn.jsdelivr.net/gh/yegor256/tacit@gh-pages/drops.min.css", rel="stylesheet"/>
  <link rel="shortcut icon" href="https://www.objectionary.com/cactus.svg"/>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
  <style>
    body { counter-reset: step; }
    section { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <section>
    <p>You came to this page from the <a href="summary.html">summary</a>.
      The page is auto-generated by the <a href="https://github.com/objectionary/benchmark">Makefile</a> at 2025-06-26 07:42
.</p>
    <pre>package org.eolang.benchmark;
import java.util.concurrent.TimeUnit;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
@BenchmarkMode({Mode.AverageTime})
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.MILLISECONDS)
@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
@Fork(2)
public class Big {
  private static final Object[] VALUES;
  
  static {
    VALUES = LongStream.range(0L, 10000000L).boxed().map(x -&gt; String.format("%04x", new Object[] { x })).toArray();
  }
  
  @Benchmark
  public long plain() {
    long acc = 0L;
    for (int idx = 0; idx &lt; VALUES.length; idx++) {
      String str = ((String)VALUES[idx]).trim();
      if (str.length() == 4)
        acc += Long.parseLong(str, 16) + 1L; 
    } 
    return acc;
  }
  
  @Benchmark
  public long streams() {
    return Stream.&lt;Object&gt;of(VALUES)
      .map(obj -&gt; (String)obj)
      .map(String::trim)
      .filter(str -&gt; (str.length() == 4))
      .map(str -&gt; Long.valueOf(Long.parseLong(str, 16) + 1L))
      .mapToLong(num -&gt; num.longValue())
      .sum();
  }
}

package org.eolang.benchmark;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@BenchmarkMode({Mode.AverageTime})
@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.MILLISECONDS)
@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class Cotl {
  public static final int N = 10000000;
  
  static long[] v;
  
  static long[] valuesLo;
  
  static long[] valuesHi;
  
  static Ref[] refs;
  
  public static class Ref {
    public int num;
    
    public Ref(int num) {
      this.num = num;
    }
  }
  
  static {
    v = IntStream.range(0, 10000000).mapToLong(i -&gt; (i % 1000)).toArray();
    valuesLo = IntStream.range(0, 10).mapToLong(i -&gt; i).toArray();
    valuesHi = IntStream.range(0, 10000000).mapToLong(i -&gt; i).toArray();
    refs = (Ref[])IntStream.range(0, 10000000).mapToObj(n -&gt; new Ref(n)).toArray(size -&gt; new Ref[size]);
  }
  
  @Benchmark
  public long sumBaseline() {
    long acc = 0L;
    for (int i = 0; i &lt; v.length; i++)
      acc += v[i]; 
    return acc;
  }
  
  @Benchmark
  public long sumOfSquaresBaseline() {
    long acc = 0L;
    for (int i = 0; i &lt; v.length; i++)
      acc += v[i] * v[i]; 
    return acc;
  }
  
  @Benchmark
  public long cartBaseline() {
    long cart = 0L;
    for (int d = 0; d &lt; valuesHi.length; d++) {
      for (int dp = 0; dp &lt; valuesLo.length; dp++)
        cart += valuesHi[d] * valuesLo[dp]; 
    } 
    return cart;
  }
  
  @Benchmark
  public long sumOfSquaresEvenBaseline() {
    long acc = 0L;
    for (int i = 0; i &lt; v.length; i++) {
      if (v[i] % 2L == 0L)
        acc += v[i] * v[i]; 
    } 
    return acc;
  }
  
  @Benchmark
  public long sumSeq() {
    long sum = LongStream.of(v).sum();
    return sum;
  }
  
  @Benchmark
  public long sumPar() {
    long sum = LongStream.of(v).parallel().sum();
    return sum;
  }
  
  @Benchmark
  public long sumOfSquaresSeq() {
    long sum = LongStream.of(v).map(d -&gt; d * d).sum();
    return sum;
  }
  
  @Benchmark
  public long sumOfSquaresPar() {
    long sum = LongStream.of(v).parallel().map(d -&gt; d * d).sum();
    return sum;
  }
  
  @Benchmark
  public long cartSeq() {
    long cart = LongStream.of(valuesHi).flatMap(d -&gt; LongStream.of(valuesLo).map(())).sum();
    return cart;
  }
  
  @Benchmark
  public long cartPar() {
    long cart = LongStream.of(valuesHi).parallel().flatMap(d -&gt; LongStream.of(valuesLo).map(())).sum();
    return cart;
  }
  
  @Benchmark
  public long sumOfSquaresEvenSeq() {
    long sum = LongStream.of(v).filter(x -&gt; (x % 2L == 0L)).map(x -&gt; x * x).sum();
    return sum;
  }
  
  @Benchmark
  public long sumOfSquaresEvenPar() {
    long sum = LongStream.of(v).parallel().filter(x -&gt; (x % 2L == 0L)).map(x -&gt; x * x).sum();
    return sum;
  }
  
  @Benchmark
  public long refBaseline() {
    long count = 0L;
    for (int i = 0; i &lt; refs.length; i++) {
      if ((refs[i]).num % 5 == 0 && (refs[i]).num % 7 == 0)
        count++; 
    } 
    return count;
  }
  
  @Benchmark
  public long refSeq() {
    long length = Stream.&lt;Ref&gt;of(refs).filter(box -&gt; (box.num % 5 == 0)).filter(box -&gt; (box.num % 7 == 0)).count();
    return length;
  }
  
  @Benchmark
  public long refPar() {
    long length = Stream.&lt;Ref&gt;of(refs).parallel().filter(box -&gt; (box.num % 5 == 0)).filter(box -&gt; (box.num % 7 == 0)).count();
    return length;
  }
}

package org.eolang.benchmark;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
@BenchmarkMode({Mode.AverageTime})
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)
@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.MILLISECONDS)
@Fork(1)
@State(Scope.Benchmark)
public class Even {
  private static final long[] VALUES;
  
  static {
    VALUES = IntStream.range(0, 100000000).mapToLong(i -&gt; (i % 1000)).toArray();
  }
  
  @Benchmark
  public long plain() {
    long acc = 0L;
    for (int idx = 0; idx &lt; VALUES.length; idx++) {
      if (idx % 2 == 0)
        acc += VALUES[idx] * VALUES[idx]; 
    } 
    return acc;
  }
  
  @Benchmark
  public long streams() {
    return LongStream.of(VALUES)
      .filter(x -&gt; (x % 2L == 0L))
      .map(x -&gt; x * x)
      .sum();
  }
}

package org.eolang.benchmark;
import java.util.concurrent.TimeUnit;
import java.util.function.LongUnaryOperator;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
@BenchmarkMode({Mode.AverageTime})
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)
@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.MILLISECONDS)
@Fork(1)
@State(Scope.Benchmark)
public class Sum {
  private static final long[] VALUES;
  
  static {
    VALUES = IntStream.range(0, 100000000).mapToLong(i -&gt; (i % 1000)).toArray();
  }
  
  @Benchmark
  public long plain() {
    LongUnaryOperator iface = num -&gt; num * num;
    long acc = 0L;
    for (int idx = 0; idx &lt; VALUES.length; idx++)
      acc += iface.applyAsLong(VALUES[idx]); 
    return acc;
  }
  
  @Benchmark
  public long streams() {
    return LongStream.of(VALUES)
      .map(num -&gt; num * num)
      .sum();
  }
}</pre>
  </section>
</body>
</html>
